name: Java CI with Gradle

on:
  pull_request:
    branches: [ "master" ]

permissions:
  pull-requests: write   # PR 코멘트를 작성하기 위해 필요
  checks: write          # dorny/test-reporter가 체크를 생성하기 위해 필요
  security-events: write # Security 탭에 결과를 올리기 위해 필요

jobs:
  build-and-scan:
    runs-on: ubuntu-latest

    steps:
      # 1. 소스 코드 체크아웃
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # 0으로 설정하면 전체 Git 히스토리를 가져옵니다.
          # Gitleaks가 PR의 base commit을 찾기 위해 필수적입니다.
          fetch-depth: 0

      # 2. JDK 21 설치
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      # gradle/actions/setup-gradle 사용 시 캐싱이 내장되어 있어 별도 cache 스텝이 불필요할 수 있습니다.
      # 공식 문서를 참고하여 중복 제거 가능
      # 3. Setup Gradle
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      # 4. Gradle Wrapper 실행 권한 부여
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      # 5. Build (테스트 제외)
      - name: Build with Gradle Wrapper
        id: build
        continue-on-error: true
        run: ./gradlew build -x test

      # Gitleaks 실행 (Secret 하드코딩 탐지)
      - name: Run Gitleaks
        id: gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_EXIT_CODE: "0" # 시크릿을 찾아도 실패하지 않아야 다음 스텝 실행 가능

      # Gitleaks 결과를 GitHub Security 탭에 업로드
      - name: Upload Gitleaks report to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: results.sarif # gitleaks-action의 기본 출력 파일 경로

      # JSON 리포트를 읽고 코멘트 내용을 가공
      - name: Create Gitleaks PR Comment
        id: create_comment
        if: always()
        run: |
          # results.sarif 파일이 없으면 스텝 종료
          if [ ! -f results.sarif ]; then
            echo "SARIF file not found. Skipping comment creation."
            echo "comment_body=✅ Gitleaks did not produce a report. No secrets found." >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # SARIF 파일에서 발견된 leak 개수 확인 (jq 쿼리 변경)
          LEAKS_COUNT=$(jq '.runs[0].results | length' results.sarif)
          
          if [ $LEAKS_COUNT -eq 0 ]; then
            BODY="✅ Gitleaks scan passed. No secrets found."
          else
            BODY="🚨 Gitleaks scan failed! Found ${LEAKS_COUNT} potential secret(s).\n\n"
            BODY+="| File | Line | Rule |\n"
            BODY+="|------|------|------|\n"
            # jq를 사용해 SARIF 파일에서 각 leak 정보를 테이블 형식으로 추가 (jq 쿼리 변경)
            BODY+=$(jq -r '.runs[0].results[] | "| \(.locations[0].physicalLocation.artifactLocation.uri) | \(.locations[0].physicalLocation.region.startLine) | \(.ruleId) |"' results.sarif)
          fi
          
          echo "comment_body<<EOF" >> $GITHUB_OUTPUT
          echo -e "${BODY}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Gitleaks 결과를 PR 코멘트로 게시
      - name: PR Comment Gitleaks Result
        if: always()
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: gitleaks-result # 코멘트 상단에 표시될 헤더
          message: ${{ steps.create_comment.outputs.comment_body }} # 이전 스텝에서 생성한 메시지를 사용 (path 대신 message)
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 빌드 또는 보안점검 실패 시 바로 종료
      - name: Fail if Gitleaks or Build failed
        if: always()
        run: |
          echo "Gitleaks outcome: ${{ steps.gitleaks.outcome }}"
          echo "Build outcome: ${{ steps.build.outcome }}"
          if [ "${{ steps.gitleaks.outcome }}" = "failure" ] || [ "${{ steps.build.outcome }}" = "failure" ]; then
            echo "❌ Either Gitleaks or Build failed. Stopping workflow."
            exit 1
          fi

  tests:
    runs-on: ubuntu-latest
    needs: build-and-scan
    steps:
      # 1. 소스 코드 체크아웃
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # 0으로 설정하면 전체 Git 히스토리를 가져옵니다.
          # Gitleaks가 PR의 base commit을 찾기 위해 필수적입니다.
          fetch-depth: 0

      # 2. JDK 21 설치
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      # gradle/actions/setup-gradle 사용 시 캐싱이 내장되어 있어 별도 cache 스텝이 불필요할 수 있습니다.
      # 공식 문서를 참고하여 중복 제거 가능
      # 3. Setup Gradle
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      # 4. Gradle Wrapper 실행 권한 부여
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      # 6. 테스트 실행 (단위테스트 + 통합테스트 + 커버리지)
      - name: Run Tests
        run: ./gradlew check --continue

      # 7. index.html로 확인하기 위한 Test Report 업로드
      - name: Upload Test Report
        if: always() # 테스트가 실패하더라도 항상 리포트를 업로드
        uses: actions/upload-artifact@v4
        with:
          name: test-report
          path: build/reports/tests/test/

      # 8. 커버리지 리포트 업로드
      - name: Upload JaCoCo Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-report
          path: build/reports/jacoco/test/html

      # 9. 테스트 실행 결과를 PR 코멘트로 게시
      - name: Report Test Results
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: JUnit Tests # 리포트 이름
          path: "build/test-results/test/TEST-*.xml" # Gradle 테스트 결과 XML 파일 경로
          reporter: java-junit # 리포트 형식
          token: ${{ secrets.GITHUB_TOKEN }}
          fail-on-error: 'false' # 테스트 실패 시 여기서 워크플로우를 중단하지 않음

      # 10. JaCoCo 커버리지 리포트를 PR 코멘트로 게시
      - name: Add JaCoCo Report to PR
        id: jacoco
        if: always()
        uses: madrapps/jacoco-report@v1.6.1
        with:
          paths: ${{ github.workspace }}/build/reports/jacoco/test/jacocoTestReport.xml
          token: ${{ secrets.GITHUB_TOKEN }}
          title: "테스트 커버리지 리포트"



