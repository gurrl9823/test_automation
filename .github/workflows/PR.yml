name: Java CI with Gradle

on:
  pull_request:
    branches: [ "master" ]

permissions:
  pull-requests: write   # PR 코멘트를 작성하기 위해 필요
  checks: write          # dorny/test-reporter가 체크를 생성하기 위해 필요

jobs:
  build-and-scan:
    runs-on: ubuntu-latest

    steps:
      # 1. 소스 코드 체크아웃
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # 0으로 설정하면 전체 Git 히스토리를 가져옵니다.
          # Gitleaks가 PR의 base commit을 찾기 위해 필수적입니다.
          fetch-depth: 0

      # 2. JDK 21 설치
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      # gradle/actions/setup-gradle 사용 시 캐싱이 내장되어 있어 별도 cache 스텝이 불필요할 수 있습니다.
      # 공식 문서를 참고하여 중복 제거 가능
      # gradle 캐싱 : 프로젝트에 사용된 라이브러리들, 변경되지 않은 코드들의 컴파일 결과들
      # 3. Setup Gradle
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      # 4. Gradle Wrapper 실행 권한 부여
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      # 5. Build (테스트 제외)
      - name: Build with Gradle Wrapper
        id: build
        continue-on-error: true
        run: ./gradlew build -x test

      # 빌드 성공 시 PR 코멘트 남기기
      - name: Comment on Build Success
        if: steps.build.outcome == 'success'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: build-status
          message: |
            ✅ **Gradle Build Succeeded!**
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 빌드 실패 시 PR 코멘트 남기기
      - name: Comment on Build Failure
        if: steps.build.outcome == 'failure'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: build-status
          message: |
            🚨 **Gradle Build Failed!**
            
            자세한 내용은 아래 링크에서 확인해주세요.
            [View Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Gitleaks 실행 (Secret 하드코딩 탐지)
      - name: Run Gitleaks
        id: gitleaks
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_EXIT_CODE: "0" # 시크릿을 찾아도 실패하지 않아야 다음 스텝 실행 가능

      # Gitleaks 결과를 기록. PR 코멘트, PR Checks, Files changed
      - name: Display Scan Results
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: results.sarif # gitleaks-action의 기본 출력 파일 경로

      # JSON 리포트를 읽고 코멘트 내용을 가공
      - name: Create Gitleaks PR Comment
        id: create_comment
        if: always()
        run: |
          # results.sarif 파일이 없으면 스텝 종료
          if [ ! -f results.sarif ]; then
            echo "SARIF file not found. Skipping comment creation."
            echo "comment_body=✅ Gitleaks did not produce a report. No secrets found." >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # SARIF 파일에서 발견된 leak 개수 확인 (jq 쿼리 변경)
          LEAKS_COUNT=$(jq '.runs[0].results | length' results.sarif)
          
          if [ $LEAKS_COUNT -eq 0 ]; then
            BODY="✅ Gitleaks scan passed. No secrets found."
          else
            BODY="🚨 Gitleaks scan failed! Found ${LEAKS_COUNT} potential secret(s).\n\n"
            BODY+="| File | Line | Rule |\n"
            BODY+="|------|------|------|\n"
            # jq를 사용해 SARIF 파일에서 각 leak 정보를 테이블 형식으로 추가 (jq 쿼리 변경)
            BODY+=$(jq -r '.runs[0].results[] | "| \(.locations[0].physicalLocation.artifactLocation.uri) | \(.locations[0].physicalLocation.region.startLine) | \(.ruleId) |"' results.sarif)
          fi
          
          echo "comment_body<<EOF" >> $GITHUB_OUTPUT
          echo -e "${BODY}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Gitleaks 결과를 PR 코멘트로 게시
      - name: PR Comment Gitleaks Result
        if: always()
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: gitleaks-result # 코멘트 상단에 표시될 헤더
          message: ${{ steps.create_comment.outputs.comment_body }} # 이전 스텝에서 생성한 메시지를 사용 (path 대신 message)
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 빌드 또는 보안점검 실패 시 바로 종료
      - name: Fail if Gitleaks or Build failed
        if: always()
        run: |
          echo "Gitleaks outcome: ${{ steps.gitleaks.outcome }}"
          echo "Build outcome: ${{ steps.build.outcome }}"
          if [ "${{ steps.gitleaks.outcome }}" = "failure" ] || [ "${{ steps.build.outcome }}" = "failure" ]; then
            echo "❌ Either Gitleaks or Build failed. Stopping workflow."
            exit 1
          fi

  tests:
    runs-on: ubuntu-latest
    needs: build-and-scan
    steps:
      # 1. 소스 코드 체크아웃
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # 0으로 설정하면 전체 Git 히스토리를 가져옵니다.
          # Gitleaks가 PR의 base commit을 찾기 위해 필수적입니다.
          fetch-depth: 0

      # 2. JDK 21 설치
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      # gradle/actions/setup-gradle 사용 시 캐싱이 내장되어 있어 별도 cache 스텝이 불필요할 수 있습니다.
      # 공식 문서를 참고하여 중복 제거 가능
      # 3. Setup Gradle
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      # 4. Gradle Wrapper 실행 권한 부여
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      # 6. 테스트 실행 (단위테스트 + 통합테스트 + 커버리지)
      - name: Run Tests
        run: ./gradlew check --continue

      # 7. index.html로 확인하기 위한 Test Report 업로드
      - name: Upload Test Report
        if: always() # 테스트가 실패하더라도 항상 리포트를 업로드
        uses: actions/upload-artifact@v4
        with:
          name: test-report
          path: build/reports/tests/test/

      # 8. 커버리지 리포트 업로드
      - name: Upload JaCoCo Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-report
          path: build/reports/jacoco/test/html

      # 9. 테스트 실행 결과를 workflow 탭에 추가
      - name: Report Test Results
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: JUnit Test Report # 리포트 이름
          path: "build/test-results/test/TEST-*.xml" # Gradle 테스트 결과 XML 파일 경로
          reporter: java-junit # 리포트 형식
          token: ${{ secrets.GITHUB_TOKEN }}
          fail-on-error: 'false' # 테스트 실패 시 여기서 워크플로우를 중단하지 않음

#      # 10. JaCoCo 커버리지 리포트를 PR 코멘트로 게시
#      - name: Add JaCoCo Report to PR
#        id: jacoco
#        if: always()
#        uses: madrapps/jacoco-report@v1.6.1
#        with:
#          paths: ${{ github.workspace }}/build/reports/jacoco/test/jacocoTestReport.xml
#          token: ${{ secrets.GITHUB_TOKEN }}
#          title: "테스트 커버리지 리포트"

      # JaCoCo XML 리포트를 직접 파싱하여 커버리지 계산
      - name: Parse JaCoCo Coverage Report
        id: jacoco
        if: always() # 테스트 실패 여부와 관계없이 항상 실행
        run: |
          # xmllint 도구를 사용해 XML 파일에서 커버리지 데이터를 추출합니다.
          METHOD_COVERED=$(xmllint --xpath 'string(//report/counter[@type="METHOD"]/@covered)' build/reports/jacoco/test/jacocoTestReport.xml)
          METHOD_MISSED=$(xmllint --xpath 'string(//report/counter[@type="METHOD"]/@missed)' build/reports/jacoco/test/jacocoTestReport.xml)
          BRANCH_COVERED=$(xmllint --xpath 'string(//report/counter[@type="BRANCH"]/@covered)' build/reports/jacoco/test/jacocoTestReport.xml)
          BRANCH_MISSED=$(xmllint --xpath 'string(//report/counter[@type="BRANCH"]/@missed)' build/reports/jacoco/test/jacocoTestReport.xml)

          # bc 도구를 사용해 소수점 계산을 수행합니다.
          METHOD_TOTAL=$(echo "$METHOD_COVERED + $METHOD_MISSED" | bc)
          if [ $METHOD_TOTAL -eq 0 ]; then
            METHOD_PERCENT=100
          else
            METHOD_PERCENT=$(echo "scale=2; $METHOD_COVERED * 100 / $METHOD_TOTAL" | bc)
          fi

          BRANCH_TOTAL=$(echo "$BRANCH_COVERED + $BRANCH_MISSED" | bc)
          if [ $BRANCH_TOTAL -eq 0 ]; then
            BRANCH_PERCENT=100
          else
            BRANCH_PERCENT=$(echo "scale=2; $BRANCH_COVERED * 100 / $BRANCH_TOTAL" | bc)
          fi

          # 코멘트 메시지 본문을 생성합니다.
          BODY="### 🧪 JaCoCo 테스트 커버리지\n\n"
          BODY+="| 측정 항목 | 커버리지 |\n"
          BODY+="|:---|:---|\n"
          BODY+="| **메소드 (Methods)** | **${METHOD_PERCENT}%** |\n"
          BODY+="| **브랜치 (Branches)** | **${BRANCH_PERCENT}%** |\n\n"

          # build.gradle의 룰(최소 60%)과 비교하여 상태 메시지를 추가합니다.
          # awk를 사용해 소수점 비교를 수행합니다.
          BRANCH_VIOLATION=$(echo "$BRANCH_PERCENT 60.0" | awk '{if ($1 < $2) print "true"; else print "false"}')

          if [ "$BRANCH_VIOLATION" = "true" ]; then
            BODY+="🚨 **커버리지 기준 미달!**\n"
            BODY+="> 브랜치 커버리지가 **${BRANCH_PERCENT}%** 로, 목표치인 **60%** 에 도달하지 못했습니다."
          else
            BODY+="✅ **커버리지 기준을 충족했습니다!**"
          fi

          # 생성된 메시지를 다음 스텝에서 사용할 수 있도록 출력 변수로 설정합니다.
          echo "comment_body<<EOF" >> $GITHUB_OUTPUT
          echo -e "${BODY}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # 위에서 생성한 커스텀 메시지를 PR 코멘트로 게시
      - name: Add Custom JaCoCo Report to PR
        if: always()
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          # 다른 코멘트와 겹치지 않도록 고유한 헤더를 사용합니다.
          header: jacoco-coverage-report
          message: ${{ steps.jacoco.outputs.comment_body }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



